Висновки:

1. Найшвидший алгоритм: 
Алгоритм Боєра-Мура показав найкращі результати як для існуючого, так і для неіснуючого підрядка.
Це пояснюється його здатністю "перестрибувати" через частини тексту, використовуючи таблицю зсувів (bad character rule). Чим довший підрядок ми шукаємо, тим ефективнішим стає цей алгоритм, оскільки довжина стрибка може зростати.

2. Стабільність KMP: 
Алгоритм Кнута-Морріса-Пратта показав середній результат.
Він не робить зайвих повернень назад по тексту (як наївний алгоритм), але змушений переглядати кожен символ тексту принаймні один раз. У Python накладні витрати на обробку індексів роблять його повільнішим за Боєра-Мура на звичайних текстах.

3. Повільність Рабіна-Карпа: 
Алгоритм Рабіна-Карпа виявився найповільнішим у даному середовищі.
Хоча теоретична складність алгоритму хороша, у Python постійний перерахунок хеш-функції (модульна арифметика) для кожного вікна є ресурсоємною операцією порівняно з простим порівнянням символів. 
Цей алгоритм краще підходить для пошуку декількох підрядків одночасно (plagiarism detection), а не одного.

4. Загальний підсумок: 
Для задач пошуку в текстових редакторах або системах обробки даних (де шукаємо один підрядок у великому тексті) алгоритм Боєра-Мура є найбільш ефективним вибором.